---
title: 如何保证 RocketMQ 消息不丢失
published: 2024-03-18
description: 从生产者、Broker、消费者三端分析消息丢失场景及解决方案
tags: [RocketMQ, 消息队列, 面试, 分布式系统]
category: 消息中间件
draft: false
---

## 核心思路

消息从生产到消费经历三个阶段，每个阶段都可能丢失，需要分别保障：

```
Producer ────────> Broker ────────> Consumer
 发送阶段           存储阶段          消费阶段
```

---

## 一、消息丢失的场景分析

### 1. 生产者端丢失

| 场景 | 原因 |
|-----|------|
| 网络异常 | 消息发出但未到达Broker，或Broker响应未返回 |
| 未检查返回值 | 使用异步/单向发送，未确认发送结果 |
| Producer宕机 | 消息还在内存中，尚未发送 |

### 2. Broker端丢失

| 场景 | 原因 |
|-----|------|
| 异步刷盘时宕机 | 消息在PageCache中还未写入磁盘 |
| 主从异步复制时主节点宕机 | 消息未同步到Slave，主节点数据丢失 |

### 3. 消费者端丢失

| 场景 | 原因 |
|-----|------|
| 自动提交Offset | 消息拉取后自动提交，但业务处理失败 |
| 业务异常未重试 | 消费失败直接返回成功，消息被跳过 |

---

## 二、解决方案

### 1. 生产者端保障

**问题：消息发送后可能丢失在网络中，或未正确处理发送结果**

**解决方案：**

| 方案 | 说明 |
|-----|------|
| **同步发送** | 等待Broker确认，不用异步/单向发送 |
| **检查返回状态** | 只有`SendStatus.SEND_OK`才算成功 |
| **重试机制** | 配置`retryTimesWhenSendFailed=3`，失败自动重试 |
| **事务消息** | 本地事务与消息发送的强一致性场景 |
| **本地消息表** | 兜底方案，先落库再异步发送，失败可补偿 |

```
发送流程：
同步发送 → 检查SEND_OK → 失败则重试 → 仍失败则记录本地表补偿
```

---

### 2. Broker端保障

**问题：消息到达Broker后，可能因刷盘或同步策略导致丢失**

**解决方案：**

| 方案 | 配置 | 说明 |
|-----|------|------|
| **同步刷盘** | `flushDiskType=SYNC_FLUSH` | 消息写入磁盘后才返回ACK |
| **同步复制** | `brokerRole=SYNC_MASTER` | 消息同步到Slave后才返回ACK |
| **Dledger模式** | 基于Raft协议 | 多数派写入成功才返回，自动主从切换 |

**四种组合对比：**

| 刷盘 | 复制 | 可靠性 | 性能 | 适用场景 |
|-----|------|-------|------|---------|
| 同步 | 同步 | 最高 | 最低 | 金融支付 |
| 同步 | 异步 | 高 | 中 | 核心业务 |
| 异步 | 同步 | 高 | 中 | 核心业务 |
| 异步 | 异步 | 一般 | 最高 | 日志采集 |

---

### 3. 消费者端保障

**问题：消息被消费但业务处理失败，或重复消费导致数据不一致**

**解决方案：**

| 方案 | 说明 |
|-----|------|
| **手动提交Offset** | 业务处理成功后才返回`CONSUME_SUCCESS` |
| **失败重试** | 返回`RECONSUME_LATER`，消息进入重试队列 |
| **消费幂等** | 通过唯一键去重，防止重复消费 |
| **死信队列监控** | 超过重试次数的消息进入死信队列，需监控告警 |

```
消费流程：
拉取消息 → 幂等检查 → 业务处理 → 成功则提交Offset
                              → 失败则返回RECONSUME_LATER
```

**幂等实现方式：**
- Redis：`SETNX`去重
- 数据库：唯一键约束
- 业务状态机：通过业务状态判断是否已处理

---

## 三、总结图示

```
┌─────────────────────────────────────────────────────────────────────┐
│                         消息不丢失全链路保障                          │
└─────────────────────────────────────────────────────────────────────┘

┌──────────────────────┐
│      Producer        │
│                      │
│  ✓ 同步发送          │
│  ✓ 检查SEND_OK       │
│  ✓ 失败重试(3次)     │
│  ✓ 事务消息/本地表   │
└──────────┬───────────┘
           │
           ▼
┌──────────────────────┐
│       Broker         │
│                      │
│  ✓ 同步刷盘          │
│  ✓ 同步复制          │
│  ✓ 多副本/Dledger    │
└──────────┬───────────┘
           │
           ▼
┌──────────────────────┐
│      Consumer        │
│                      │
│  ✓ 手动提交Offset    │
│  ✓ 失败返回重试      │
│  ✓ 消费幂等          │
│  ✓ 死信队列告警      │
└──────────────────────┘
```

---

## 四、面试回答模板

> **面试官：如何保证RocketMQ消息不丢失？**

消息可能在三个阶段丢失，需要分别保障：

**1. 生产者端**
- 使用**同步发送**，必须检查返回状态是`SEND_OK`
- 配置**发送重试**，失败自动重试其他Broker
- 强一致性场景用**事务消息**，兜底用**本地消息表**

**2. Broker端**
- **同步刷盘**：消息写入磁盘后才返回，防止宕机丢数据
- **同步复制**：消息同步到Slave后才返回，防止主节点故障
- 高可用场景可用**Dledger模式**，基于Raft实现多数派写入

**3. 消费者端**
- **业务成功后才提交Offset**，失败返回`RECONSUME_LATER`触发重试
- 必须实现**消费幂等**，防止重复消费导致数据错乱
- 监控**死信队列**，超过重试次数的消息及时告警处理

实际项目中会根据业务重要程度选择配置组合，金融场景用同步刷盘+同步复制，日志场景可以用异步方式提升性能。

---

## 五、追问预判

| 追问 | 回答要点 |
|-----|---------|
| 同步刷盘和异步刷盘性能差多少？ | 差距较大，同步约1-3万TPS，异步可达10万+ |
| 为什么消费端必须做幂等？ | 网络超时、Rebalance、重试都可能导致重复投递，MQ只保证At Least Once |
| 事务消息的原理？ | Half消息 → 本地事务 → Commit/Rollback，支持回查机制 |
| 消息积压怎么处理？ | 扩容Consumer、增加消费线程、临时Topic分流 |

---

*适用面试级别：P6-P8 / 3-1及以上*
