---
title: Synchronized锁升级机制深度解析
published: 2026-01-04
description: 全面解析 synchronized 从偏向锁→轻量级锁→重量级锁的升级流程、Mark Word 结构变化，以及 JDK 15+ 废弃偏向锁的五大原因。
tags: [Java, Synchronized, 并发编程]
category: Java并发编程
draft: false
---

# Synchronized 锁升级机制深度解析

## 一、锁升级概述

### 1.1 为什么需要锁升级

在 JDK 1.6 之前，synchronized 是一个重量级锁，每次加锁都需要进行系统调用，涉及用户态到内核态的切换，性能开销很大。

**性能问题的根源：**

```
┌─────────────────────────────────────────────────────────────┐
│                      重量级锁的代价                          │
├─────────────────────────────────────────────────────────────┤
│  1. 系统调用：pthread_mutex_lock / pthread_mutex_unlock     │
│  2. 用户态 ↔ 内核态切换：约 1000+ 个时钟周期                  │
│  3. 线程上下文切换：约 5000~20000 个时钟周期                  │
│  4. 线程阻塞与唤醒：需要操作系统介入                          │
└─────────────────────────────────────────────────────────────┘
```

**实际场景分析：**

| 场景 | 比例 | 特点 |
|------|------|------|
| 无竞争 | ~70-80% | 只有一个线程访问同步块 |
| 轻微竞争 | ~15-25% | 线程交替执行，很少真正冲突 |
| 激烈竞争 | ~5-10% | 多线程同时竞争同一把锁 |

既然大部分情况下锁是无竞争或轻微竞争的，那么使用重量级锁就是"杀鸡用牛刀"。因此 JDK 1.6 引入了**锁升级机制**。

### 1.2 锁的四种状态

```
┌──────────────────────────────────────────────────────────────────┐
│                         锁升级方向（不可逆）                       │
│                                                                  │
│   无锁 ──────→ 偏向锁 ──────→ 轻量级锁 ──────→ 重量级锁           │
│    │            │              │               │                │
│    │            │              │               │                │
│  无同步       单线程         CAS自旋         OS互斥量             │
│  开销最小     访问优化       短期竞争        长期竞争             │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘
```

---

## 二、对象头与 Mark Word

### 2.1 对象内存布局

要理解锁升级，首先需要了解 Java 对象在内存中的结构：

```
┌─────────────────────────────────────────────────────────────────┐
│                        Java 对象内存布局                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    对象头 (Header)                       │   │
│  │  ┌─────────────────────────────────────────────────┐    │   │
│  │  │             Mark Word (8 bytes/64位)             │    │   │
│  │  │          存储锁信息、GC信息、HashCode等            │    │   │
│  │  └─────────────────────────────────────────────────┘    │   │
│  │  ┌─────────────────────────────────────────────────┐    │   │
│  │  │         Class Pointer (4/8 bytes)               │    │   │
│  │  │            指向类元数据的指针                      │    │   │
│  │  └─────────────────────────────────────────────────┘    │   │
│  │  ┌─────────────────────────────────────────────────┐    │   │
│  │  │         Array Length (4 bytes, 仅数组)           │    │   │
│  │  └─────────────────────────────────────────────────┘    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                  实例数据 (Instance Data)                │   │
│  │                    对象的字段值                          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                  对齐填充 (Padding)                      │   │
│  │                  保证8字节对齐                           │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 Mark Word 的结构（64位 JVM）

Mark Word 是实现锁升级的关键，它在不同锁状态下存储不同的信息：

```
┌────────────────────────────────────────────────────────────────────────────┐
│                           Mark Word (64 bits)                               │
├────────────────────────────────────────────────────────────────────────────┤
│                                                                            │
│  ┌─────────────────────────────────────────────────────────┬─────┬──────┐ │
│  │                      锁状态标志位说明                     │biased│ lock │ │
│  ├─────────────────────────────────────────────────────────┼─────┼──────┤ │
│  │  无锁态 (Normal)                                         │  0  │  01  │ │
│  │  偏向锁 (Biased)                                         │  1  │  01  │ │
│  │  轻量级锁 (Lightweight Locked)                           │  -  │  00  │ │
│  │  重量级锁 (Heavyweight Locked)                           │  -  │  10  │ │
│  │  GC标记 (Marked for GC)                                  │  -  │  11  │ │
│  └─────────────────────────────────────────────────────────┴─────┴──────┘ │
│                                                                            │
└────────────────────────────────────────────────────────────────────────────┘
```

### 2.3 各状态下 Mark Word 的详细布局

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│ 64位 Mark Word 在不同锁状态下的布局                                               │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│ 【无锁态】 lock=01, biased=0                                                    │
│ ┌────────────────────────┬──────────────┬─────────┬────────┬────────┬────────┐ │
│ │     unused (25 bits)    │ hashcode(31) │unused(1)│ age(4) │biased=0│lock=01 │ │
│ └────────────────────────┴──────────────┴─────────┴────────┴────────┴────────┘ │
│                                                                                 │
│ 【偏向锁】 lock=01, biased=1                                                    │
│ ┌────────────────────────┬──────────────┬─────────┬────────┬────────┬────────┐ │
│ │    thread ID (54 bits)  │ epoch(2)     │unused(1)│ age(4) │biased=1│lock=01 │ │
│ └────────────────────────┴──────────────┴─────────┴────────┴────────┴────────┘ │
│                                                                                 │
│ 【轻量级锁】 lock=00                                                            │
│ ┌────────────────────────────────────────────────────────────────────┬────────┐ │
│ │              ptr_to_lock_record (62 bits)                          │lock=00 │ │
│ │                    指向栈中锁记录的指针                              │        │ │
│ └────────────────────────────────────────────────────────────────────┴────────┘ │
│                                                                                 │
│ 【重量级锁】 lock=10                                                            │
│ ┌────────────────────────────────────────────────────────────────────┬────────┐ │
│ │              ptr_to_heavyweight_monitor (62 bits)                  │lock=10 │ │
│ │                    指向 ObjectMonitor 的指针                        │        │ │
│ └────────────────────────────────────────────────────────────────────┴────────┘ │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

---

## 三、偏向锁（Biased Locking）

### 3.1 设计思想

偏向锁的核心思想是：**如果一个线程获得了锁，那么锁就进入偏向模式，此时 Mark Word 的结构变为偏向锁结构，当这个线程再次请求锁时，无需做任何同步操作。**

这是基于一个经验假设：**大多数情况下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获得**。

### 3.2 偏向锁的获取流程

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              偏向锁获取流程                                   │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
                    ┌───────────────────────────────┐
                    │ 检查 Mark Word 的锁标志位      │
                    │ 是否为偏向锁 (biased=1,lock=01)│
                    └───────────────────────────────┘
                                    │
                    ┌───────────────┴───────────────┐
                    │                               │
                    ▼                               ▼
            ┌─────────────┐                 ┌─────────────┐
            │  是偏向锁    │                 │ 不是偏向锁   │
            └─────────────┘                 └─────────────┘
                    │                               │
                    ▼                               ▼
        ┌──────────────────────┐         ┌──────────────────────┐
        │ 检查 Thread ID       │         │  使用 CAS 将当前线程   │
        │ 是否指向当前线程      │         │  ID 设置到 Mark Word  │
        └──────────────────────┘         └──────────────────────┘
                    │                               │
        ┌───────────┴──────────┐         ┌─────────┴─────────┐
        │                      │         │                   │
        ▼                      ▼         ▼                   ▼
   ┌─────────┐           ┌─────────┐ ┌─────────┐       ┌─────────┐
   │ 是当前   │           │不是当前 │ │CAS 成功 │       │CAS 失败 │
   │ 线程     │           │线程     │ │获得偏向锁│       │存在竞争 │
   └─────────┘           └─────────┘ └─────────┘       └─────────┘
        │                      │           │               │
        ▼                      ▼           ▼               ▼
   ┌─────────┐           ┌─────────┐ ┌─────────┐     ┌─────────┐
   │直接执行  │           │撤销偏向锁│ │执行同步  │     │升级为    │
   │同步代码  │           │等待安全点│ │代码块   │     │轻量级锁  │
   └─────────┘           └─────────┘ └─────────┘     └─────────┘
```

### 3.3 偏向锁的撤销

偏向锁的撤销需要等待**全局安全点（Safe Point）**，此时：

```java
// 偏向锁撤销的触发条件
1. 当有其他线程尝试竞争偏向锁时
2. 调用对象的 hashCode() 方法时（因为偏向锁的 Mark Word 中没有存储 hashCode 的空间）
3. 调用 wait()/notify() 时

// 撤销过程
┌────────────────────────────────────────────────────────────────┐
│ 1. 暂停拥有偏向锁的线程（在安全点）                               │
│ 2. 检查持有偏向锁的线程状态：                                    │
│    - 如果线程不存活，将对象头设置为无锁状态                       │
│    - 如果线程存活：                                             │
│      a. 线程不在同步块中 → 恢复到无锁状态                        │
│      b. 线程仍在同步块中 → 升级为轻量级锁                        │
│ 3. 唤醒被暂停的线程                                             │
└────────────────────────────────────────────────────────────────┘
```

### 3.4 批量重偏向与批量撤销

JVM 引入了两个优化机制来减少偏向锁撤销的开销：

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                            批量重偏向 (Bulk Rebias)                          │
├─────────────────────────────────────────────────────────────────────────────┤
│ 触发条件：同一个类的对象被不同线程多次撤销偏向（阈值：20次）                    │
│                                                                             │
│ 场景：线程A创建了大量对象并偏向自己，然后线程B接手访问这些对象                  │
│                                                                             │
│ 处理：不撤销偏向锁，而是将类的 epoch 值加1，让这批对象可以重新偏向新线程         │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│                            批量撤销 (Bulk Revoke)                            │
├─────────────────────────────────────────────────────────────────────────────┤
│ 触发条件：同一个类的对象被频繁撤销（阈值：40次）                               │
│                                                                             │
│ 场景：某个类的对象确实存在激烈竞争，不适合使用偏向锁                           │
│                                                                             │
│ 处理：禁用该类的偏向锁功能，后续该类新建的对象直接为无锁状态                    │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 四、轻量级锁（Lightweight Locking）

### 4.1 设计思想

轻量级锁的核心思想是：**在没有多线程竞争的前提下，减少传统重量级锁产生的性能消耗**。

它采用 **CAS（Compare And Swap）** 操作来加锁和解锁，避免了使用互斥量的开销。

**适用场景：** 线程交替执行同步块，几乎不存在竞争。

### 4.2 轻量级锁的加锁流程

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                            轻量级锁加锁流程                                   │
└─────────────────────────────────────────────────────────────────────────────┘

步骤1: 在当前线程栈帧中创建锁记录（Lock Record）
┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│         线程栈帧                                                            │
│    ┌───────────────────┐                                                   │
│    │                   │                                                   │
│    ├───────────────────┤                                                   │
│    │   Lock Record     │ ← 锁记录                                          │
│    │  ┌─────────────┐  │                                                   │
│    │  │Displaced    │  │ ← 用于存储对象原来的 Mark Word                     │
│    │  │Mark Word    │  │                                                   │
│    │  ├─────────────┤  │                                                   │
│    │  │ owner       │  │ ← 指向锁对象的指针                                 │
│    │  └─────────────┘  │                                                   │
│    ├───────────────────┤                                                   │
│    │                   │                                                   │
│    └───────────────────┘                                                   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

步骤2: 复制 Mark Word 到锁记录，然后 CAS 替换
┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│   对象头                              线程栈帧                               │
│  ┌─────────────┐                    ┌───────────────────┐                  │
│  │ Mark Word   │ ───复制───────────→│ Displaced Mark    │                  │
│  │ (原始值)    │                    │ Word (副本)       │                  │
│  └─────────────┘                    └───────────────────┘                  │
│        │                                    │                              │
│        │                                    │                              │
│        ▼                                    ▼                              │
│  ┌─────────────┐    CAS替换        ┌───────────────────┐                  │
│  │ ptr_to_lock │ ←───────────────→ │ Lock Record 地址  │                  │
│  │ _record|00  │                   │                   │                  │
│  └─────────────┘                   └───────────────────┘                  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.3 完整的加锁解锁流程图

```
                              轻量级锁获取
                                  │
                                  ▼
                    ┌─────────────────────────┐
                    │ 1. 在栈帧创建 Lock Record │
                    │ 2. 复制 Mark Word 到      │
                    │    Displaced Mark Word   │
                    └─────────────────────────┘
                                  │
                                  ▼
                    ┌─────────────────────────┐
                    │ 使用 CAS 尝试将对象头的   │
                    │ Mark Word 替换为指向     │
                    │ Lock Record 的指针       │
                    └─────────────────────────┘
                                  │
                    ┌─────────────┴─────────────┐
                    │                           │
                    ▼                           ▼
             ┌───────────┐               ┌───────────┐
             │ CAS 成功   │               │ CAS 失败  │
             │ 获得轻量级锁│               │           │
             └───────────┘               └───────────┘
                    │                           │
                    │                           ▼
                    │               ┌─────────────────────┐
                    │               │ 检查 Mark Word 是否  │
                    │               │ 指向当前线程的栈帧   │
                    │               └─────────────────────┘
                    │                           │
                    │               ┌───────────┴───────────┐
                    │               │                       │
                    │               ▼                       ▼
                    │        ┌───────────┐          ┌───────────┐
                    │        │ 是（锁重入）│          │ 否（竞争） │
                    │        │ 记录重入次数│          │ 自旋等待  │
                    │        └───────────┘          └───────────┘
                    │               │                       │
                    │               │                       ▼
                    │               │              ┌─────────────────┐
                    │               │              │ 自旋超过阈值？   │
                    │               │              └─────────────────┘
                    │               │                       │
                    │               │               ┌───────┴───────┐
                    │               │               │               │
                    │               │               ▼               ▼
                    │               │          ┌────────┐     ┌────────┐
                    │               │          │ 是     │     │ 否     │
                    │               │          │膨胀为  │     │继续自旋│
                    │               │          │重量级锁│     └────────┘
                    │               │          └────────┘
                    ▼               ▼
            ┌─────────────────────────────┐
            │        执行同步代码块         │
            └─────────────────────────────┘
                            │
                            ▼
                    ┌───────────────┐
                    │  轻量级锁解锁  │
                    └───────────────┘
                            │
                            ▼
            ┌─────────────────────────────┐
            │ CAS 将 Displaced Mark Word  │
            │ 替换回对象头的 Mark Word      │
            └─────────────────────────────┘
                            │
                ┌───────────┴───────────┐
                │                       │
                ▼                       ▼
         ┌───────────┐           ┌───────────┐
         │ CAS 成功   │           │ CAS 失败  │
         │ 解锁成功   │           │ 有竞争    │
         └───────────┘           └───────────┘
                                        │
                                        ▼
                              ┌─────────────────┐
                              │ 释放锁并唤醒     │
                              │ 等待的线程       │
                              └─────────────────┘
```

### 4.4 自旋优化

#### 4.4.1 普通自旋

```java
// 伪代码：普通自旋
int spinCount = 0;
while (!tryLock()) {
    spinCount++;
    if (spinCount > SPIN_THRESHOLD) {  // 默认10次
        // 升级为重量级锁
        inflate();
        break;
    }
    // 自旋等待（空循环）
}
```

#### 4.4.2 适应性自旋（Adaptive Spinning）

JDK 1.6 引入了适应性自旋，自旋次数不再固定：

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              适应性自旋策略                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌───────────────────────────────────────────────────────────────────────┐ │
│  │ 如果在同一个锁对象上：                                                  │ │
│  │   - 上次自旋成功获取锁 → 本次增加自旋次数（认为很可能再次成功）           │ │
│  │   - 上次自旋失败       → 本次减少自旋次数或直接跳过自旋                  │ │
│  │   - 从未成功获取过锁   → 可能直接跳过自旋，避免浪费CPU                   │ │
│  └───────────────────────────────────────────────────────────────────────┘ │
│                                                                             │
│  JVM 会根据运行时统计数据动态调整：                                          │
│    - 自旋次数阈值                                                           │
│    - 是否启用自旋                                                           │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 五、重量级锁（Heavyweight Locking）

### 5.1 设计思想

当锁竞争激烈时，轻量级锁的 CAS 自旋会消耗大量 CPU 资源，此时需要升级为重量级锁。

重量级锁依赖于**操作系统的互斥量（Mutex）**实现，会导致线程阻塞和唤醒，涉及用户态到内核态的切换。

### 5.2 ObjectMonitor 结构

每个 Java 对象都可以关联一个 ObjectMonitor：

```cpp
// HotSpot 中 ObjectMonitor 的核心结构（简化）
ObjectMonitor {
    _header       // Mark Word
    _count        // 重入次数
    _waiters      // 等待线程数
    _recursions   // 递归次数
    _owner        // 当前持有锁的线程
    _WaitSet      // 调用 wait() 的线程队列
    _EntryList    // 等待获取锁的线程队列
    _cxq          // 竞争队列（单向链表）
}
```

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          ObjectMonitor 结构                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│     Java 对象                           ObjectMonitor                       │
│    ┌──────────────┐                    ┌───────────────────────────────┐   │
│    │  Mark Word   │ ─ptr_to_monitor──→ │ _header (displaced mark word) │   │
│    │  (...|10)    │                    │ _owner  (持有锁的线程)         │   │
│    └──────────────┘                    │ _count  (重入计数)             │   │
│                                        │                               │   │
│                                        │ ┌─────────────────────────┐   │   │
│                                        │ │     _cxq (竞争队列)      │   │   │
│                                        │ │  ┌───┐ ┌───┐ ┌───┐      │   │   │
│                                        │ │  │T3 │→│T4 │→│T5 │      │   │   │
│                                        │ │  └───┘ └───┘ └───┘      │   │   │
│                                        │ └─────────────────────────┘   │   │
│                                        │                               │   │
│                                        │ ┌─────────────────────────┐   │   │
│                                        │ │   _EntryList (阻塞队列)  │   │   │
│                                        │ │  ┌───┐ ┌───┐            │   │   │
│                                        │ │  │T1 │↔│T2 │            │   │   │
│                                        │ │  └───┘ └───┘            │   │   │
│                                        │ └─────────────────────────┘   │   │
│                                        │                               │   │
│                                        │ ┌─────────────────────────┐   │   │
│                                        │ │   _WaitSet (等待队列)    │   │   │
│                                        │ │  ┌───┐ ┌───┐            │   │   │
│                                        │ │  │T6 │↔│T7 │            │   │   │
│                                        │ │  └───┘ └───┘            │   │   │
│                                        │ └─────────────────────────┘   │   │
│                                        └───────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 5.3 重量级锁的工作流程

```
                                线程尝试获取锁
                                      │
                                      ▼
                        ┌─────────────────────────┐
                        │ 检查 _owner 是否为 null  │
                        └─────────────────────────┘
                                      │
                        ┌─────────────┴─────────────┐
                        │                           │
                        ▼                           ▼
                 ┌───────────┐               ┌───────────┐
                 │ _owner=null│               │_owner≠null│
                 │ (锁空闲)   │               │ (锁被占用) │
                 └───────────┘               └───────────┘
                        │                           │
                        ▼                           ▼
            ┌──────────────────────┐    ┌──────────────────────┐
            │ CAS 设置 _owner     │    │ 检查是否是锁重入      │
            │ 为当前线程           │    └──────────────────────┘
            └──────────────────────┘              │
                        │                  ┌──────┴──────┐
                ┌───────┴───────┐          │             │
                │               │          ▼             ▼
                ▼               ▼    ┌──────────┐  ┌──────────┐
         ┌──────────┐    ┌──────────┐│ 是(重入)  │  │ 否(竞争)  │
         │ CAS 成功  │    │ CAS 失败 ││_recursions│  │加入_cxq  │
         │ 获得锁    │    │ 加入_cxq ││    ++    │  │  队列    │
         └──────────┘    └──────────┘└──────────┘  └──────────┘
                                                        │
                                                        ▼
                                              ┌─────────────────┐
                                              │ 自旋尝试获取锁   │
                                              └─────────────────┘
                                                        │
                                                ┌───────┴───────┐
                                                │               │
                                                ▼               ▼
                                         ┌──────────┐    ┌──────────┐
                                         │ 成功     │    │ 失败     │
                                         │ 获得锁   │    │ 阻塞等待 │
                                         └──────────┘    │ (park)   │
                                                         └──────────┘
```

### 5.4 锁释放与线程唤醒

```
                                线程释放锁
                                    │
                                    ▼
                    ┌───────────────────────────┐
                    │ _recursions-- (减少重入计数)│
                    └───────────────────────────┘
                                    │
                                    ▼
                    ┌───────────────────────────┐
                    │ _recursions == 0 ?        │
                    └───────────────────────────┘
                                    │
                        ┌───────────┴───────────┐
                        │                       │
                        ▼                       ▼
                 ┌───────────┐           ┌───────────┐
                 │ 是        │           │ 否        │
                 │ 真正释放锁 │           │ 继续持有  │
                 └───────────┘           └───────────┘
                        │
                        ▼
            ┌──────────────────────┐
            │ 设置 _owner = null   │
            └──────────────────────┘
                        │
                        ▼
            ┌──────────────────────┐
            │ 检查 _EntryList      │
            │ 或 _cxq 是否有等待线程│
            └──────────────────────┘
                        │
                ┌───────┴───────┐
                │               │
                ▼               ▼
         ┌──────────┐    ┌──────────┐
         │ 有等待者  │    │ 无等待者 │
         │ unpark   │    │ 直接返回 │
         │ 唤醒线程  │    │         │
         └──────────┘    └──────────┘
```

---

## 六、锁升级完整流程

### 6.1 全景图

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                              锁升级完整流程                                       │
└─────────────────────────────────────────────────────────────────────────────────┘

                            新建对象
                               │
            ┌──────────────────┴──────────────────┐
            │                                      │
            ▼                                      ▼
   ┌─────────────────┐                   ┌─────────────────┐
   │ 偏向锁延迟开启前 │                   │ 偏向锁延迟开启后 │
   │ (JVM启动4秒内)  │                   │ (4秒后)         │
   │                 │                   │                 │
   │ 对象为无锁态    │                   │ 对象为匿名偏向态 │
   │ biased=0,lock=01│                   │ biased=1,lock=01│
   │ (可偏向)        │                   │ threadId=0      │
   └─────────────────┘                   └─────────────────┘
            │                                      │
            └──────────────────┬───────────────────┘
                               │
                               ▼ 首次获取锁
                    ┌─────────────────────┐
                    │     偏向锁状态       │
                    │  biased=1, lock=01  │
                    │  threadId=当前线程   │
                    └─────────────────────┘
                               │
                               │ 同一线程再次获取
                               ├─────────────────────────┐
                               │                         │
                               │ 其他线程获取            ▼
                               │                  直接执行（无同步）
                               ▼
                    ┌─────────────────────┐
                    │   偏向锁撤销        │
                    │   (等待安全点)      │
                    └─────────────────────┘
                               │
            ┌──────────────────┴──────────────────┐
            │                                      │
            ▼                                      ▼
   ┌─────────────────┐                   ┌─────────────────┐
   │ 原持有者不在同步块│                   │ 原持有者在同步块 │
   │ 恢复为无锁态     │                   │ 升级为轻量级锁   │
   └─────────────────┘                   └─────────────────┘
            │                                      │
            └──────────────────┬───────────────────┘
                               │
                               ▼
                    ┌─────────────────────┐
                    │     轻量级锁状态     │
                    │      lock=00        │
                    │  ptr→Lock Record   │
                    └─────────────────────┘
                               │
                               │ 无竞争：CAS成功
                               ├─────────────────────────┐
                               │                         │
                               │ 有竞争：CAS失败          ▼
                               │                    正常执行并解锁
                               ▼
                    ┌─────────────────────┐
                    │     CAS 自旋        │
                    │   (适应性自旋)      │
                    └─────────────────────┘
                               │
                               │ 自旋成功
                               ├─────────────────────────┐
                               │                         │
                               │ 自旋失败（超过阈值）      ▼
                               │                    获得锁并执行
                               ▼
                    ┌─────────────────────┐
                    │  锁膨胀 (Inflation)  │
                    │  创建 ObjectMonitor │
                    └─────────────────────┘
                               │
                               ▼
                    ┌─────────────────────┐
                    │    重量级锁状态      │
                    │      lock=10        │
                    │  ptr→ObjectMonitor │
                    └─────────────────────┘
                               │
                               ▼
                    ┌─────────────────────┐
                    │ 未获取锁的线程阻塞   │
                    │ 进入 _EntryList     │
                    │ (OS 级别阻塞)       │
                    └─────────────────────┘
```

### 6.2 升级时机总结

| 状态转换 | 触发条件 | 说明 |
|----------|----------|------|
| 无锁 → 偏向锁 | 首次有线程访问同步块 | CAS 设置线程ID |
| 偏向锁 → 轻量级锁 | 有其他线程竞争 | 需要在安全点撤销偏向锁 |
| 偏向锁 → 无锁 | 调用hashCode()/原持有者退出同步块 | 偏向锁被撤销 |
| 轻量级锁 → 重量级锁 | CAS 自旋失败超过阈值 | 锁膨胀，创建 ObjectMonitor |
| 重量级锁 → 轻量级锁 | **不会降级** | 一旦膨胀，不会恢复 |

---

## 七、为什么废弃偏向锁（JDK 15+）

### 7.1 废弃背景

JEP 374 在 JDK 15 中**默认禁用**偏向锁，并在后续版本中**完全移除**。

```
JDK 15: 默认关闭偏向锁 (-XX:+UseBiasedLocking 可手动开启)
JDK 18: 偏向锁相关代码被移除
```

### 7.2 废弃的五大原因

#### 原因一：维护成本高

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                            代码复杂度分析                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  偏向锁涉及的 HotSpot 代码路径：                                              │
│                                                                             │
│  1. 对象创建路径：需要设置偏向锁标志                                          │
│  2. 锁获取路径：需要检查偏向状态、线程ID                                       │
│  3. 锁撤销路径：需要等待安全点、遍历栈帧                                       │
│  4. 批量操作：批量重偏向、批量撤销的逻辑                                       │
│  5. GC 交互：需要处理偏向锁对象的特殊情况                                      │
│  6. JIT 编译：需要生成偏向锁相关的机器码                                       │
│                                                                             │
│  这些路径相互交织，增加了代码理解和维护的难度                                  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 原因二：安全点停顿问题

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         偏向锁撤销的延迟影响                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  偏向锁撤销必须在安全点进行：                                                 │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 时间线                                                               │   │
│  │ ────────────────────────────────────────────────────────────────── │   │
│  │                                                                     │   │
│  │ 线程A ═══════════╗                                                  │   │
│  │                  ║ 请求撤销偏向锁                                    │   │
│  │                  ║                                                  │   │
│  │ 线程B ──────────────────────┬───────────────────────────────────   │   │
│  │                             │                                       │   │
│  │                             │ 等待安全点                             │   │
│  │                             │ (所有线程暂停)                         │   │
│  │                             ▼                                       │   │
│  │ 所有线程 ═════════════════ [STW] ════════════════════════          │   │
│  │                         撤销偏向锁                                  │   │
│  │                                                                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  频繁的偏向锁撤销会导致频繁的 STW，影响应用吞吐量                             │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 原因三：现代硬件发展

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          硬件演进对比                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  2006年 (偏向锁引入时):                                                      │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  • 单核/双核 CPU 为主                                                │   │
│  │  • 原子操作 (CAS) 开销相对较大                                        │   │
│  │  • 单线程场景占比很高                                                 │   │
│  │  • 偏向锁的优化收益明显                                               │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  2024年 (现代硬件):                                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  • 多核 CPU 普及 (8核、16核甚至更多)                                   │   │
│  │  • 原子操作经过大量优化，开销大幅降低                                  │   │
│  │  • 多线程编程成为主流                                                 │   │
│  │  • 偏向锁适用场景减少，收益降低                                        │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  CAS 操作延迟对比 (示意):                                                    │
│    2006年: ~100 CPU cycles                                                  │
│    2024年: ~10-20 CPU cycles                                                │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 原因四：应用特征变化

```java
// 2006年典型的单线程序列化访问模式
synchronized(this) {
    // 总是同一个线程访问
    // 偏向锁优势明显
}

// 2024年典型的并发访问模式
// 线程池 + 任务分发
ExecutorService executor = Executors.newFixedThreadPool(16);
for (int i = 0; i < 1000; i++) {
    executor.submit(() -> {
        synchronized(sharedObject) {
            // 不同线程交替访问
            // 偏向锁频繁撤销，反而成为负担
        }
    });
}
```

#### 原因五：性能收益测试数据

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       OpenJDK 性能测试结论 (JEP 374)                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  基准测试结果：                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 场景                          │ 偏向锁开启  │ 偏向锁关闭  │ 差异     │   │
│  ├───────────────────────────────┼────────────┼────────────┼─────────┤   │
│  │ 低竞争场景                     │   100ms    │   102ms    │  +2%    │   │
│  │ 中等竞争场景                   │   100ms    │    98ms    │  -2%    │   │
│  │ 高竞争场景                     │   100ms    │    95ms    │  -5%    │   │
│  │ 启动时间                       │   100ms    │    97ms    │  -3%    │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  结论：                                                                     │
│  • 偏向锁在现代应用中的收益有限（通常 < 5%）                                  │
│  • 在某些场景下反而有性能损失                                                │
│  • 维护成本与收益不成正比                                                    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 7.3 替代方案

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           JDK 15+ 的锁优化策略                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. 直接使用轻量级锁                                                        │
│     • 新对象直接为无锁状态                                                   │
│     • 首次加锁直接升级为轻量级锁                                             │
│     • CAS 操作在现代CPU上足够快                                              │
│                                                                             │
│  2. 持续优化轻量级锁                                                        │
│     • 更智能的适应性自旋                                                     │
│     • 更优化的 CAS 实现                                                     │
│                                                                             │
│  3. Lock Coarsening (锁粗化)                                                │
│     • JIT 编译时合并相邻的同步块                                             │
│                                                                             │
│  4. Lock Elision (锁消除)                                                   │
│     • 逃逸分析发现锁不会逃逸时，直接消除锁                                    │
│                                                                             │
│  5. 推荐使用 java.util.concurrent                                           │
│     • ReentrantLock                                                         │
│     • StampedLock                                                           │
│     • 原子类                                                                 │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 八、总结与面试要点

### 8.1 锁升级核心要点

| 锁状态 | 适用场景 | 加锁方式 | 优点 | 缺点 |
|--------|----------|----------|------|------|
| 偏向锁 | 单线程 | 比较ThreadID | 无额外开销 | 撤销需STW |
| 轻量级锁 | 竞争不激烈 | CAS + 自旋 | 避免阻塞 | 自旋消耗CPU |
| 重量级锁 | 竞争激烈 | OS Mutex | 不浪费CPU | 线程切换开销 |

### 8.2 高频面试问题

**Q1: 锁能降级吗？**
> 不能。锁升级是单向的：偏向锁 → 轻量级锁 → 重量级锁。一旦升级，不会恢复到之前的状态。

**Q2: 为什么偏向锁撤销需要 STW？**
> 因为需要遍历当前持有偏向锁的线程栈，检查是否还在同步块中。这个操作需要线程暂停才能保证一致性。

**Q3: 自旋次数怎么确定？**
> JDK 1.6+ 使用适应性自旋，根据上次自旋结果动态调整：成功则增加，失败则减少。

**Q4: 调用 hashCode() 会怎样？**
> 如果是偏向锁状态，会撤销偏向锁（因为 Mark Word 没有空间存储 hashCode）；如果是无锁状态，hashCode 存入 Mark Word。

**Q5: wait()/notify() 为什么必须用重量级锁？**
> 因为 wait/notify 机制依赖于 ObjectMonitor 中的 _WaitSet 队列，这是重量级锁独有的数据结构。

### 8.3 实践建议

```java
// 1. 减少锁的持有时间
synchronized(this) {
    // 只在必要时持有锁
    // 耗时操作移到锁外
}

// 2. 减少锁的粒度
// Bad: 锁整个对象
synchronized(this) { ... }

// Good: 锁特定资源
synchronized(specificResource) { ... }

// 3. 考虑使用 Lock 接口
ReentrantLock lock = new ReentrantLock();
if (lock.tryLock(timeout, TimeUnit.MILLISECONDS)) {
    try {
        // ...
    } finally {
        lock.unlock();
    }
}

// 4. 读多写少场景使用读写锁
ReadWriteLock rwLock = new ReentrantReadWriteLock();
rwLock.readLock().lock();  // 读锁可共享
rwLock.writeLock().lock(); // 写锁独占
```
