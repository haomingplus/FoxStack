---
title: RR隔离级别下的幻读场景深度分析
published: 2023-04-11
description: 通过具体案例分析可重复读级别下快照读与当前读的不同表现，理解MVCC机制如何保证查询结果一致性
tags: [MySQL, MVCC, 幻读, 可重复读, 快照读, 事务隔离]
category: MySQL性能优化
draft: false
---

## 面试题

在默认隔离级别（可重复读）下，事务 T1 先查询表中满足 A=1 的记录（结果为1条），此时事务 T2 插入一条新的 A=1 记录并提交，T1 再次查询 A=1，结果会是多少？为什么？

## 直接答案

**结果仍然是 1 条**。

因为在 RR（可重复读）级别下，普通 SELECT 是**快照读**，事务 T1 在第一次查询时生成 Read View，后续查询**复用**这个 Read View。T2 插入的新数据对 T1 不可见，所以两次查询结果一致。

## 详细分析

### 一、场景还原

```sql
-- 初始数据
CREATE TABLE test (
    id INT PRIMARY KEY,
    a INT,
    INDEX idx_a(a)
);
INSERT INTO test VALUES (1, 1);  -- 只有一条 A=1 的记录
```

```
事务 T1                            事务 T2
─────────────────────────────────────────────────────────────
BEGIN;
SELECT * FROM test WHERE a = 1;
-- 结果：1 条记录 (id=1, a=1)
-- 此时生成 Read View
                                   BEGIN;
                                   INSERT INTO test VALUES (2, 1);
                                   COMMIT;
                                   -- 插入成功

SELECT * FROM test WHERE a = 1;
-- 结果：？？？
COMMIT;
```

### 二、答案解析

#### 2.1 普通 SELECT（快照读）—— 结果是 1 条

```
事务 T1 (TRX_ID=100)               事务 T2 (TRX_ID=101)
─────────────────────────────────────────────────────────────
BEGIN;

SELECT * FROM test WHERE a = 1;
-- 生成 Read View：
--   m_ids = [100]
--   min_trx_id = 100
--   max_trx_id = 101
--   creator_trx_id = 100
-- 结果：1 条

                                   BEGIN;
                                   INSERT INTO test VALUES (2, 1);
                                   -- 新数据 TRX_ID = 101
                                   COMMIT;

SELECT * FROM test WHERE a = 1;
-- 复用 Read View
-- 新数据判断：trx_id(101) >= max_trx_id(101) → 不可见
-- 结果：仍然是 1 条 ✓

COMMIT;
```

**可见性判断**：

```
新插入的记录 (id=2, a=1, TRX_ID=101)

判断规则：
┌─────────────────────────────────────────────────────────────┐
│  trx_id(101) >= max_trx_id(101) ?                          │
│  → 是，说明该数据是在 Read View 创建之后产生的               │
│  → 不可见 ✗                                                 │
└─────────────────────────────────────────────────────────────┘

所以 T1 第二次查询看不到 T2 插入的数据
结果仍然是 1 条
```

#### 2.2 如果使用当前读 —— 结果是 2 条

```
事务 T1                            事务 T2
─────────────────────────────────────────────────────────────
BEGIN;
SELECT * FROM test WHERE a = 1;
-- 快照读，结果：1 条

                                   BEGIN;
                                   INSERT INTO test VALUES (2, 1);
                                   COMMIT;

SELECT * FROM test WHERE a = 1 FOR UPDATE;
-- 当前读！绕过 MVCC，读取最新数据
-- 结果：2 条 ← 能看到新插入的数据

COMMIT;
```

### 三、两种查询方式对比

| 查询方式 | SQL | 结果 | 原因 |
|---------|-----|------|------|
| **快照读** | `SELECT * FROM test WHERE a=1` | 1 条 | 复用 Read View，新数据不可见 |
| **当前读** | `SELECT * FROM test WHERE a=1 FOR UPDATE` | 2 条 | 绕过 MVCC，读最新数据 |

### 四、图解 MVCC 可见性

```
时间线：
─────────────────────────────────────────────────────────────────→

T1 开始          T2 插入并提交        T1 第二次查询      T1 提交
   │                  │                    │               │
   ▼                  ▼                    ▼               ▼
┌──────┐          ┌──────┐            ┌──────┐        ┌──────┐
│BEGIN │          │INSERT│            │SELECT│        │COMMIT│
│      │          │COMMIT│            │      │        │      │
└──────┘          └──────┘            └──────┘        └──────┘
   │                                       │
   │         Read View 创建                │
   │         max_trx_id = 101              │
   │                  │                    │
   │                  │                    │
   │                  ▼                    │
   │         ┌───────────────┐             │
   │         │ T2 的数据      │             │
   │         │ TRX_ID = 101   │◄────────────┤
   │         │ >= max_trx_id  │    不可见！  │
   │         │ 所以不可见     │             │
   │         └───────────────┘             │
   │                                       │
   └───────────────────────────────────────┘
              T1 的 Read View 始终不变
```

### 五、延伸：如果 T1 做了 UPDATE 会怎样？

```
事务 T1                            事务 T2
─────────────────────────────────────────────────────────────
BEGIN;
SELECT * FROM test WHERE a = 1;
-- 快照读，结果：1 条 (id=1)

                                   BEGIN;
                                   INSERT INTO test VALUES (2, 1);
                                   COMMIT;

UPDATE test SET a = 1 WHERE a = 1;
-- 当前读！会更新 2 条记录（包括 id=2）
-- 返回：Rows matched: 2

SELECT * FROM test WHERE a = 1;
-- 快照读，但 id=2 的 TRX_ID 变成了 T1 的 ID
-- 结果：2 条！

COMMIT;
```

**为什么 UPDATE 后快照读能看到新数据？**

```
UPDATE 是当前读，会读取并修改 id=2 这条记录
修改后，id=2 的 TRX_ID 变成 T1 的事务 ID

┌────────────────────────────────────────────────┐
│  id=2 的 TRX_ID 从 101 变成 100               │
│                                                │
│  可见性判断：                                   │
│  trx_id(100) == creator_trx_id(100)           │
│  → 是自己修改的，可见 ✓                         │
└────────────────────────────────────────────────┘

所以后续的快照读能看到 id=2
```

### 六、各种场景结果汇总

| 场景 | T1 第二次查询方式 | 结果 | 解释 |
|-----|------------------|------|------|
| 纯快照读 | `SELECT ... WHERE a=1` | 1 条 | MVCC 保护，新数据不可见 |
| 当前读 | `SELECT ... FOR UPDATE` | 2 条 | 绕过 MVCC，读最新数据 |
| 先 UPDATE 再快照读 | `UPDATE` 后 `SELECT` | 2 条 | UPDATE 把新数据"纳入"当前事务 |
| RC 隔离级别 | `SELECT ... WHERE a=1` | 2 条 | 每次 SELECT 新建 Read View |

### 七、这是幻读吗？

```
严格来说：

场景1：纯快照读
├── 第一次查询：1 条
├── 第二次查询：1 条
└── 结果一致，没有幻读 ✓

场景2：快照读 + UPDATE + 快照读
├── 第一次查询：1 条
├── UPDATE 后查询：2 条
└── 结果不一致，类似幻读（但这是预期行为）

场景3：快照读 + 当前读
├── 第一次查询（快照读）：1 条
├── 第二次查询（当前读）：2 条
└── 不是同类型查询的对比，不算严格的幻读
```

### 八、总结

**面试回答模板**：

> "在 RR 隔离级别下，T1 第二次查询的结果**仍然是 1 条**。
>
> **原因**：普通 SELECT 是快照读，T1 在第一次查询时生成 Read View，并在整个事务期间复用。T2 插入的新数据的 TRX_ID 大于等于 Read View 的 max_trx_id，根据 MVCC 可见性规则判定为不可见。
>
> **但如果**：
> - 使用 `SELECT ... FOR UPDATE`（当前读）→ 能看到 2 条
> - 先执行 `UPDATE ... WHERE a=1`（当前读）再查询 → 也能看到 2 条
>
> 这就是 MVCC 的核心作用：让快照读在事务内看到的数据始终一致，实现可重复读的语义。"
