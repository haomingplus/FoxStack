---
title: MySQL MVCC多版本并发控制机制详解
published: 2020-06-14
description: 深入剖析MVCC的核心组件（隐藏字段、Undo Log、Read View）、版本链构建原理、可见性判断规则及RC与RR的实现差异
tags: [MySQL, MVCC, 事务, Undo Log, Read View, InnoDB]
category: MySQL性能优化
draft: false
---

## 面试题

介绍一下 MySQL 的 MVCC 机制

## 一句话回答

MVCC（Multi-Version Concurrency Control，多版本并发控制）是 InnoDB 实现高并发的核心机制，通过**隐藏字段**、**Undo Log 版本链**、**Read View** 三大组件，让读操作不加锁，实现读写不阻塞，大幅提升并发性能。

## 详细解析

### 一、为什么需要 MVCC？

**没有 MVCC 的世界**：

```
传统锁机制：
┌─────────┐          ┌─────────┐
│  读操作  │ ──阻塞── │  写操作  │
└─────────┘          └─────────┘

问题：
- 读写互相阻塞
- 并发性能差
- 大量锁等待和死锁
```

**有 MVCC 的世界**：

```
MVCC 机制：
┌─────────┐          ┌─────────┐
│  读操作  │ ──并行── │  写操作  │
└─────────┘          └─────────┘
     │                    │
     ▼                    ▼
 读取历史版本          修改最新版本

优势：
- 读写不阻塞
- 高并发性能
- 无锁读取
```

### 二、MVCC 三大核心组件

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           MVCC 核心组件                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   ┌─────────────┐    ┌─────────────┐    ┌─────────────┐                    │
│   │  隐藏字段    │    │  Undo Log   │    │  Read View  │                    │
│   │             │    │   版本链     │    │   读视图    │                    │
│   └─────────────┘    └─────────────┘    └─────────────┘                    │
│         │                  │                  │                            │
│         ▼                  ▼                  ▼                            │
│   记录版本信息        保存历史版本        决定可见性                         │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

#### 2.1 隐藏字段

InnoDB 为每行数据添加三个隐藏字段：

| 字段名 | 大小 | 说明 |
|-------|------|------|
| **DB_TRX_ID** | 6 字节 | 最后修改该行的事务 ID |
| **DB_ROLL_PTR** | 7 字节 | 回滚指针，指向 Undo Log 中的上一个版本 |
| **DB_ROW_ID** | 6 字节 | 隐藏主键（无主键时自动生成） |

```
表中一行数据的完整结构：

┌─────────────────────────────────────────────────────────────┐
│                        数据行                                │
├─────────┬─────────┬────────────┬────────────┬───────────────┤
│   id    │  name   │ DB_TRX_ID  │ DB_ROLL_PTR│  DB_ROW_ID    │
├─────────┼─────────┼────────────┼────────────┼───────────────┤
│    1    │  张三   │    100     │  0x12345   │     auto      │
└─────────┴─────────┴────────────┴────────────┴───────────────┘
                          │            │
                          │            └──→ 指向 Undo Log
                          └──→ 修改该行的事务ID
```

---

#### 2.2 Undo Log 版本链

每次修改数据时，旧版本会写入 Undo Log，通过 `DB_ROLL_PTR` 形成**版本链**。

**版本链形成过程**：

```sql
-- 初始数据
INSERT INTO user(id, name) VALUES(1, '张三');  -- 事务100

-- 第一次修改
UPDATE user SET name = '李四' WHERE id = 1;    -- 事务101

-- 第二次修改
UPDATE user SET name = '王五' WHERE id = 1;    -- 事务102
```

```
版本链结构：

┌─────────────────────────────────────────────────────────────────────────────┐
│                              版本链                                          │
└─────────────────────────────────────────────────────────────────────────────┘

当前数据行（最新版本）
┌─────────┬─────────┬────────────┬────────────┐
│  id=1   │ name=王五│ TRX_ID=102 │ ROLL_PTR ──┼──┐
└─────────┴─────────┴────────────┴────────────┘  │
                                                  │
                                                  ▼
                              Undo Log（版本1）
                    ┌─────────┬─────────┬────────────┬────────────┐
                    │  id=1   │ name=李四│ TRX_ID=101 │ ROLL_PTR ──┼──┐
                    └─────────┴─────────┴────────────┴────────────┘  │
                                                                      │
                                                                      ▼
                                              Undo Log（版本2）
                                    ┌─────────┬─────────┬────────────┬────────────┐
                                    │  id=1   │ name=张三│ TRX_ID=100 │ ROLL_PTR=NULL│
                                    └─────────┴─────────┴────────────┴────────────┘
                                                                            │
                                                                            ▼
                                                                         最初版本

时间线：张三(100) → 李四(101) → 王五(102)
```

---

#### 2.3 Read View（读视图）

Read View 是事务进行**快照读**时生成的数据快照，用于判断版本链中哪个版本对当前事务可见。

**Read View 包含四个核心字段**：

| 字段 | 说明 |
|-----|------|
| **m_ids** | 生成 Read View 时，当前系统中**活跃**（未提交）的事务 ID 列表 |
| **min_trx_id** | m_ids 中的**最小值** |
| **max_trx_id** | 生成 Read View 时，系统应该分配给**下一个事务**的 ID |
| **creator_trx_id** | 创建该 Read View 的事务 ID |

```
示例：

当前活跃事务：101, 103, 105
下一个事务ID：107

Read View 内容：
┌────────────────────────────────────────┐
│  m_ids = [101, 103, 105]               │
│  min_trx_id = 101                      │
│  max_trx_id = 107                      │
│  creator_trx_id = 当前事务ID           │
└────────────────────────────────────────┘
```

### 三、可见性判断规则

当事务读取数据时，从版本链的**最新版本开始**，依次判断每个版本是否可见。

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          可见性判断流程                                       │
└─────────────────────────────────────────────────────────────────────────────┘

                    从版本链最新版本开始
                              │
                              ▼
              ┌───────────────────────────────┐
              │  trx_id == creator_trx_id ?   │
              │      （是自己修改的？）          │
              └───────────────────────────────┘
                     │是              │否
                     ▼                ▼
                ┌────────┐   ┌───────────────────────────┐
                │ 可见 ✓ │   │  trx_id < min_trx_id ?    │
                └────────┘   │  （事务已提交？）           │
                             └───────────────────────────┘
                                    │是              │否
                                    ▼                ▼
                               ┌────────┐   ┌───────────────────────────┐
                               │ 可见 ✓ │   │  trx_id >= max_trx_id ?   │
                               └────────┘   │  （事务在之后开始？）       │
                                            └───────────────────────────┘
                                                   │是              │否
                                                   ▼                ▼
                                              ┌─────────┐   ┌───────────────────┐
                                              │ 不可见 ✗│   │ trx_id 在 m_ids 中?│
                                              └─────────┘   └───────────────────┘
                                                                  │是        │否
                                                                  ▼          ▼
                                                             ┌─────────┐ ┌────────┐
                                                             │ 不可见 ✗│ │ 可见 ✓ │
                                                             └─────────┘ └────────┘
```

**判断规则总结表**：

| 条件 | 可见性 | 原因 |
|-----|--------|------|
| `trx_id == creator_trx_id` | ✅ 可见 | 自己修改的，当然可见 |
| `trx_id < min_trx_id` | ✅ 可见 | 事务在 Read View 创建前已提交 |
| `trx_id >= max_trx_id` | ❌ 不可见 | 事务在 Read View 创建后才开始 |
| `trx_id 在 m_ids 中` | ❌ 不可见 | 事务还未提交 |
| `trx_id 不在 m_ids 中` | ✅ 可见 | 事务已提交 |

### 四、完整示例演示

```sql
-- 假设有一张 user 表，初始数据：
-- id=1, name='张三', TRX_ID=100

-- 当前活跃事务：无
-- 下一个事务ID：105
```

**场景演示**：

```
时间线：

T1: 事务A(ID=105) 开始
T2: 事务B(ID=106) 开始
T3: 事务B 更新 name='李四' 并提交
T4: 事务A 查询 id=1
T5: 事务C(ID=107) 更新 name='王五'（未提交）
T6: 事务A 再次查询 id=1
```

**T4 时刻，事务A 的 Read View**（RR 级别，第一次 SELECT 时生成）：

```
Read View:
├── m_ids = [105]        # 事务A自己活跃
├── min_trx_id = 105
├── max_trx_id = 107
└── creator_trx_id = 105
```

**版本链**：

```
当前行: name='李四', TRX_ID=106
           │
           ▼
Undo Log: name='张三', TRX_ID=100
```

**可见性判断**：

```
1. 检查最新版本 (name='李四', TRX_ID=106)
   - trx_id(106) != creator_trx_id(105) ❌
   - trx_id(106) < min_trx_id(105) ? 否 ❌
   - trx_id(106) >= max_trx_id(107) ? 否 ❌
   - trx_id(106) 在 m_ids[105] 中? 否 → 可见 ✅

结果：事务A 读取到 name='李四'
```

**T6 时刻**（RR 级别，复用 Read View）：

```
版本链:
当前行: name='王五', TRX_ID=107  ← 事务C未提交
           │
           ▼
Undo Log: name='李四', TRX_ID=106
           │
           ▼
Undo Log: name='张三', TRX_ID=100
```

**可见性判断**：

```
1. 检查最新版本 (name='王五', TRX_ID=107)
   - trx_id(107) >= max_trx_id(107) ? 是 → 不可见 ❌
   
2. 检查下一个版本 (name='李四', TRX_ID=106)
   - 不在 m_ids 中 → 可见 ✅

结果：事务A 仍然读取到 name='李四'（可重复读！）
```

### 五、RC 与 RR 的核心区别

| 对比项 | RC（读已提交） | RR（可重复读） |
|-------|---------------|---------------|
| **Read View 生成时机** | 每次 SELECT 都生成新的 | 第一次 SELECT 时生成，后续复用 |
| **效果** | 能看到其他事务最新提交的数据 | 整个事务期间看到的数据一致 |
| **问题** | 存在不可重复读 | 解决不可重复读 |

**图解对比**：

```
RC 级别：每次 SELECT 生成新 Read View

事务A                              事务B
─────────────────────────────────────────────────
BEGIN;
SELECT name ...;  ← ReadView1: 看到 '张三'
                                   BEGIN;
                                   UPDATE name='李四';
                                   COMMIT;
SELECT name ...;  ← ReadView2: 看到 '李四' ← 结果变了！
COMMIT;

─────────────────────────────────────────────────

RR 级别：复用第一次的 Read View

事务A                              事务B
─────────────────────────────────────────────────
BEGIN;
SELECT name ...;  ← ReadView1: 看到 '张三'
                                   BEGIN;
                                   UPDATE name='李四';
                                   COMMIT;
SELECT name ...;  ← 复用 ReadView1: 仍然看到 '张三' ← 结果一致！
COMMIT;
```

### 六、快照读与当前读

MVCC 只在**快照读**时生效，**当前读**会读取最新数据并加锁。

| 类型 | SQL 示例 | 特点 |
|-----|---------|------|
| **快照读** | `SELECT * FROM t WHERE ...` | 不加锁，读取 MVCC 版本链 |
| **当前读** | `SELECT ... FOR UPDATE`<br>`SELECT ... LOCK IN SHARE MODE`<br>`INSERT/UPDATE/DELETE` | 加锁，读取最新已提交数据 |

```sql
-- 快照读：走 MVCC，读历史版本
SELECT * FROM user WHERE id = 1;

-- 当前读：加排他锁，读最新版本
SELECT * FROM user WHERE id = 1 FOR UPDATE;

-- DML 操作都是当前读
UPDATE user SET name = '赵六' WHERE id = 1;
```

### 七、MVCC 解决了什么问题？

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           MVCC 解决的问题                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────┐                                                       │
│  │     读写并发     │  → 读不阻塞写，写不阻塞读                              │
│  └─────────────────┘                                                       │
│                                                                             │
│  ┌─────────────────┐                                                       │
│  │      脏读       │  → 只能读到已提交的版本                                 │
│  └─────────────────┘                                                       │
│                                                                             │
│  ┌─────────────────┐                                                       │
│  │    不可重复读    │  → RR 级别复用 Read View，保证一致性                    │
│  └─────────────────┘                                                       │
│                                                                             │
│  ┌─────────────────┐                                                       │
│  │   部分幻读      │  → 快照读通过 MVCC 避免（当前读需要间隙锁）              │
│  └─────────────────┘                                                       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 八、MVCC 速查表

| 组件 | 作用 | 存储位置 |
|-----|------|---------|
| DB_TRX_ID | 记录修改该行的事务 ID | 行数据中 |
| DB_ROLL_PTR | 指向上一个版本 | 行数据中 |
| Undo Log | 保存历史版本数据 | Undo 表空间 |
| Read View | 可见性判断依据 | 内存中 |

| 隔离级别 | Read View 生成时机 | 效果 |
|---------|-------------------|------|
| RC | 每次 SELECT | 能看到最新提交 |
| RR | 第一次 SELECT | 整个事务一致 |

### 九、总结

**面试回答模板**：

> "MVCC 是 InnoDB 实现高并发的核心机制，主要由三个组件构成：
>
> 1. **隐藏字段**：每行数据包含 `DB_TRX_ID`（事务ID）和 `DB_ROLL_PTR`（回滚指针）
>
> 2. **Undo Log 版本链**：每次修改都会将旧版本写入 Undo Log，通过回滚指针形成版本链
>
> 3. **Read View**：快照读时生成，包含活跃事务列表，用于判断版本可见性
>
> **可见性规则**：从版本链最新版本开始，判断 TRX_ID 与 Read View 的关系，找到第一个可见版本。
>
> **RC 与 RR 区别**：RC 每次 SELECT 生成新 Read View，能看到最新提交；RR 只在第一次 SELECT 生成，整个事务复用，保证可重复读。
>
> **MVCC 优势**：读写不阻塞，大幅提升并发性能，是 MySQL 高性能的关键。"
