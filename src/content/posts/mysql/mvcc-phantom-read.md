---
title: InnoDB的MVCC能解决幻读问题吗？
published: 2022-07-03
description: 深入分析MVCC在快照读场景下如何避免幻读，以及为什么当前读场景仍需要间隙锁来彻底解决幻读问题
tags: [MySQL, MVCC, 幻读, 间隙锁, InnoDB, 事务隔离]
category: MySQL性能优化
draft: false
---

## 面试题

InnoDB 的 MVCC 能解决幻读问题吗？

## 一句话回答

**部分能，部分不能**。MVCC 在**快照读**场景下可以避免幻读，但在**当前读**场景下无法避免，需要配合**间隙锁（Gap Lock）** 才能彻底解决。这就是为什么说 MySQL 的 RR 级别通过 "MVCC + 间隙锁" 解决幻读。

## 详细解析

### 一、先回顾：什么是幻读？

幻读是指在同一事务中，**两次相同的范围查询返回的行数不同**。

```
标准幻读场景：

事务A                              事务B
─────────────────────────────────────────────────
BEGIN;
SELECT * FROM user WHERE age > 20;
-- 返回 2 行 (id=1, id=2)
                                   BEGIN;
                                   INSERT INTO user(id, age) VALUES(3, 25);
                                   COMMIT;
SELECT * FROM user WHERE age > 20;
-- 返回 3 行 (id=1, id=2, id=3)
-- 多出一行"幻影"数据！
COMMIT;
```

### 二、结论速查表

| 读取类型 | MVCC 能否避免幻读 | 原因 |
|---------|------------------|------|
| **快照读** | ✅ 能 | Read View 固定，看不到新插入的数据 |
| **当前读** | ❌ 不能 | 当前读绕过 MVCC，直接读最新数据 |

```
完整解决方案：

┌─────────────────────────────────────────────────────────────┐
│              MySQL RR 级别解决幻读                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   快照读场景 ──→ MVCC（Read View）                          │
│                                                             │
│   当前读场景 ──→ 间隙锁（Gap Lock / Next-Key Lock）          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

### 三、快照读场景：MVCC 可以避免幻读

#### 3.1 原理

在 RR 级别下，事务第一次 SELECT 时生成 Read View，后续所有快照读都复用这个 Read View。由于 Read View 是固定的，新插入的数据对当前事务不可见。

#### 3.2 演示

```
事务A (TRX_ID=100)                  事务B (TRX_ID=101)
─────────────────────────────────────────────────────────────
BEGIN;
SELECT * FROM user WHERE age > 20;
-- 生成 Read View: m_ids=[100], max_trx_id=101
-- 返回 2 行

                                   BEGIN;
                                   INSERT INTO user(id, age) 
                                   VALUES(3, 25);  -- TRX_ID=101
                                   COMMIT;

SELECT * FROM user WHERE age > 20;
-- 复用 Read View
-- 新数据 TRX_ID=101 >= max_trx_id=101 → 不可见
-- 仍然返回 2 行 ✓（没有幻读）

COMMIT;
```

#### 3.3 可见性判断

```
新插入的数据 (TRX_ID=101)：

Read View:
├── m_ids = [100]
├── max_trx_id = 101
└── creator_trx_id = 100

判断：trx_id(101) >= max_trx_id(101) → 不可见 ✓

结论：MVCC 通过 Read View 机制，让新插入的数据对当前事务不可见，避免了幻读。
```

---

### 四、当前读场景：MVCC 无法避免幻读

#### 4.1 原理

当前读（`SELECT ... FOR UPDATE`、`UPDATE`、`DELETE`）会**绕过 MVCC**，直接读取最新已提交的数据，因此能看到其他事务新插入的行。

#### 4.2 演示（无间隙锁的情况）

```
假设 RR 级别没有间隙锁（实际上 MySQL RR 有间隙锁）：

事务A                              事务B
─────────────────────────────────────────────────────────────
BEGIN;
SELECT * FROM user WHERE age > 20 FOR UPDATE;
-- 当前读，返回 2 行，对这 2 行加锁

                                   BEGIN;
                                   INSERT INTO user(id, age) 
                                   VALUES(3, 25);
                                   -- 如果没有间隙锁，可以成功插入
                                   COMMIT;

SELECT * FROM user WHERE age > 20 FOR UPDATE;
-- 当前读，返回 3 行（幻读发生！）

COMMIT;
```

#### 4.3 为什么当前读无法用 MVCC？

```
当前读的本质是要操作"最新数据"：

UPDATE user SET name = '李四' WHERE age > 20;

如果 UPDATE 走 MVCC：
1. 可能更新的是旧版本数据
2. 会导致数据不一致
3. 会丢失其他事务的修改

所以 DML 和 SELECT ... FOR UPDATE 必须读取最新数据，
这就绕过了 MVCC 的保护。
```

---

### 五、间隙锁：当前读场景的幻读解决方案

#### 5.1 间隙锁原理

MySQL 在 RR 级别下，对当前读加**间隙锁（Gap Lock）**，锁住数据之间的"空隙"，阻止其他事务在这些间隙中插入新数据。

```
数据：age = 18, 22, 30

SELECT * FROM user WHERE age > 20 FOR UPDATE;

加锁范围：
      18        22        30        +∞
       │         │         │         │
───────●─────────●─────────●─────────→
             │         │         │
             └────┬────┴────┬────┘
                  │         │
            间隙锁(18,22]  间隙锁(22,30]  间隙锁(30,+∞)
                  │         │         │
                  └─────────┴─────────┘
                        │
              这些间隙都被锁住，无法插入
```

#### 5.2 演示（有间隙锁）

```
事务A                              事务B
─────────────────────────────────────────────────────────────
BEGIN;
SELECT * FROM user WHERE age > 20 FOR UPDATE;
-- 当前读，返回 2 行
-- 同时加间隙锁，锁住 (20, +∞) 的范围

                                   BEGIN;
                                   INSERT INTO user(id, age) 
                                   VALUES(3, 25);
                                   -- 阻塞！25 在间隙锁范围内

-- 事务A 继续执行...

COMMIT;  -- 释放锁

                                   -- 事务B 此时才能执行插入
                                   COMMIT;
```

#### 5.3 Next-Key Lock

实际上 MySQL 使用的是 **Next-Key Lock = 行锁 + 间隙锁**：

```
Next-Key Lock 示意：

数据：id = 1, 5, 10

SELECT * FROM user WHERE id > 3 FOR UPDATE;

加锁：
- 行锁：锁住 id=5, id=10
- 间隙锁：锁住 (3,5), (5,10), (10,+∞)

合起来就是 Next-Key Lock：(3,5], (5,10], (10,+∞)
                           左开右闭
```

---

### 六、特殊情况：快照读 + 当前读混用

即使 MVCC 保护了快照读，如果事务中**混用快照读和当前读**，仍可能出现"类幻读"现象。

```
事务A                              事务B
─────────────────────────────────────────────────────────────
BEGIN;
SELECT * FROM user WHERE age > 20;
-- 快照读，返回 2 行 (id=1, id=2)

                                   BEGIN;
                                   INSERT INTO user(id, age) 
                                   VALUES(3, 25);
                                   COMMIT;

UPDATE user SET name = 'test' WHERE age > 20;
-- 当前读！会更新 3 行（包括新插入的 id=3）

SELECT * FROM user WHERE age > 20;
-- 快照读，返回 3 行！
-- 因为 id=3 被当前事务更新过，TRX_ID 变成当前事务ID，变得可见了

COMMIT;

这不是严格意义的幻读，但行为类似，是"快照读被当前读污染"
```

**图解**：

```
初始状态：
id=1, age=22, TRX_ID=50
id=2, age=25, TRX_ID=50

事务A (TRX_ID=100) 开始，生成 Read View: max_trx_id=101

事务B (TRX_ID=101) 插入：
id=3, age=25, TRX_ID=101  ← 对事务A不可见（101 >= 101）

事务A 执行 UPDATE ... WHERE age > 20：
id=3 被更新，TRX_ID 变成 100  ← 变成事务A自己的修改

事务A 再次快照读：
id=3, TRX_ID=100 == creator_trx_id(100) → 可见！
```

---

### 七、完整对比表

| 场景 | 是否有幻读 | 解决机制 | 说明 |
|-----|-----------|---------|------|
| 纯快照读 | ❌ 无 | MVCC (Read View) | Read View 固定，新数据不可见 |
| 纯当前读 | ❌ 无 | 间隙锁 | 锁住间隙，阻止插入 |
| 快照读 + 当前读混用 | ⚠️ 可能有 | 需要注意 | 当前读可能"污染"快照读 |
| RC 级别当前读 | ✅ 有 | 无间隙锁 | RC 级别不加间隙锁 |

---

### 八、不同隔离级别对比

| 隔离级别 | 快照读 | 当前读 | 幻读 |
|---------|--------|--------|------|
| **RC** | 每次新建 Read View | 只有行锁 | 可能发生 |
| **RR** | 复用 Read View | 行锁 + 间隙锁 | 基本解决 |

```
RC 级别为什么有幻读：
1. 快照读：每次生成新 Read View，能看到新提交的数据
2. 当前读：没有间隙锁，新数据可以插入

RR 级别为什么没有幻读：
1. 快照读：复用 Read View，看不到新数据
2. 当前读：间隙锁阻止新数据插入
```

---

### 九、总结

**面试回答模板**：

> "InnoDB 的 MVCC **部分能**解决幻读问题：
>
> **快照读场景**：MVCC 可以避免幻读。因为 RR 级别下 Read View 在第一次 SELECT 时生成并复用，新插入的数据对当前事务不可见。
>
> **当前读场景**：MVCC 无法避免幻读。因为当前读（`FOR UPDATE`、DML）绕过 MVCC 直接读最新数据。MySQL 通过**间隙锁**来解决，锁住数据间的间隙，阻止其他事务插入新数据。
>
> 所以完整地说，MySQL RR 级别通过 **MVCC + 间隙锁** 共同解决幻读：
> - 快照读靠 MVCC
> - 当前读靠间隙锁
>
> 需要注意的是，如果在同一事务中**混用快照读和当前读**，可能出现类似幻读的现象，因为当前读会把新数据的 TRX_ID 改成当前事务ID，使其对后续快照读可见。"
