---
title: MySQL索引为什么用B+树而不是B树或哈希表？
published: 2019-08-15T10:30:00Z
description: 深入解析MySQL选择B+树作为索引数据结构的技术原因，对比B树、哈希表等结构的优劣
tags: [MySQL, 数据库, 索引优化, 数据结构, B+树]
category: 数据库原理
draft: false
---

# MySQL索引为什么用B+树

这是一个经典的数据库面试题，要回答好这个问题，需要理解不同数据结构的特性以及MySQL的实际使用场景。

## 一、常见索引数据结构对比

### 1. 哈希表（Hash Table）

**优点：**
- O(1)的查询时间复杂度，单条记录查询极快

**缺点：**
- **不支持范围查询**：无法高效执行 `WHERE age BETWEEN 20 AND 30` 这类查询
- **不支持排序**：无法利用索引进行 ORDER BY 操作
- **不支持最左前缀匹配**：无法支持模糊查询如 `LIKE 'abc%'`
- 哈希冲突处理增加复杂度

### 2. 二叉搜索树（BST）

**优点：**
- 支持范围查询和排序
- 实现相对简单

**缺点：**
- **可能退化成链表**：在顺序插入时，树高为 O(n)，查询效率退化
- **树的高度过高**：即使是平衡二叉树，百万级数据树高也达到20层左右，磁盘IO次数太多

### 3. 平衡二叉树（AVL / 红黑树）

**优点：**
- 保证树的平衡，查询效率稳定在 O(log n)
- 支持范围查询

**缺点：**
- **树高依然较高**：每个节点只存储一个键值，100万数据需要约20次IO
- **不适合磁盘存储**：节点分散，局部性差，缓存命中率低

### 4. B树（B-Tree）

**优点：**
- **多路平衡查找树**：每个节点可存储多个键值，大大降低树高
- 1000万数据，3-4层即可完成查询
- 适合磁盘存储，减少IO次数

**缺点：**
- **非叶子节点也存储数据**：导致每个节点能存储的键值数量减少
- **范围查询效率不高**：需要进行中序遍历，涉及多次随机IO

## 二、B+树的优势

MySQL的InnoDB存储引擎选择B+树，是因为它完美解决了上述问题：

### 1. 结构特点

```
B+树的特点：
├── 非叶子节点不存储数据，只存储索引键
├── 所有数据都存储在叶子节点
├── 叶子节点之间通过指针连接，形成有序链表
└── 相同层级的节点通过指针连接
```

### 2. 核心优势

#### (1) **更矮的树高，更少的IO**

- 非叶子节点不存数据，只存索引键，每个节点能存储更多的键
- InnoDB的一个节点（页）大小为16KB
- 假设主键bigint(8B) + 指针(6B) = 14B，一个节点可存 16KB/14B ≈ 1170个键
- 三层B+树可以存储：1170 × 1170 × 16 ≈ **2000万**条记录
- 查询只需要 **3次IO**（根节点通常在内存中，实际只需2次磁盘IO）

#### (2) **范围查询效率高**

```sql
SELECT * FROM user WHERE age BETWEEN 20 AND 30;
```

- B树：需要中序遍历，涉及多个节点的随机访问
- **B+树**：只需定位到起始叶子节点，然后顺序遍历链表即可，**顺序IO效率高**

#### (3) **查询性能稳定**

- B树：数据分布在所有节点，查询路径不确定
- **B+树**：所有查询都必须到达叶子节点，路径长度稳定

#### (4) **天然支持全表扫描**

- B树：需要中序遍历整棵树
- **B+树**：只需遍历叶子节点链表，效率极高

#### (5) **更好的磁盘预读性能**

操作系统一般以页（4KB或8KB）为单位进行磁盘预读：
- B+树的叶子节点存储的是连续的数据
- 预读时能加载更多有用数据
- 提高缓存命中率

## 三、实际案例对比

### 场景：1000万用户数据，按年龄查询

**二叉树：**
- 树高：约 23 层
- 磁盘IO：23 次
- 查询时间：约 230ms（假设每次IO 10ms）

**B树（度为100）：**
- 树高：约 4 层
- 磁盘IO：4 次
- 查询时间：约 40ms
- 范围查询需要树内跳转

**B+树（度为100）：**
- 树高：约 3 层
- 磁盘IO：3 次（根节点常驻内存，实际2次）
- 查询时间：约 20ms
- **范围查询直接链表遍历，额外耗时极小**

## 四、为什么不是哈希索引？

MySQL的Memory引擎支持哈希索引，但InnoDB主要用B+树：

```sql
-- 哈希索引适合的场景
SELECT * FROM user WHERE id = 12345;  -- 精确匹配，O(1)

-- 哈希索引不支持的场景
SELECT * FROM user WHERE age > 20;     -- 范围查询 ❌
SELECT * FROM user ORDER BY age;      -- 排序 ❌
SELECT * FROM user WHERE name LIKE 'zhang%';  -- 前缀匹配 ❌
```

## 五、总结

MySQL选择B+树作为索引结构的根本原因：

1. **树高低**：3-4层即可存储千万级数据，IO次数少
2. **范围查询优**：叶子节点链表结构，顺序IO效率高
3. **性能稳定**：所有查询路径长度一致
4. **全表扫描快**：叶子节点链表遍历
5. **局部性好**：适合磁盘预读和缓存机制

这些特性完美契合了数据库的实际使用场景：
- 海量数据存储在磁盘
- 查询类型多样（等值、范围、排序）
- 需要稳定的查询性能

---

**扩展思考：**
- 为什么MongoDB使用B树而不是B+树？
- 聚簇索引和非聚簇索引在B+树中的区别？
- 联合索引在B+树中如何存储？

希望这篇文章能帮助你深入理解MySQL索引的设计原理！
