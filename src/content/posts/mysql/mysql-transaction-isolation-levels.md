---
title: MySQL事务隔离级别详解与实战分析
published: 2022-03-18
description: 深入理解四种事务隔离级别的原理、解决的并发问题、MVCC实现机制，以及不同场景下的选择策略
tags: [MySQL, 事务, 隔离级别, MVCC, 并发控制, 锁机制]
category: MySQL性能优化
draft: false
---

## 面试题

MySQL 的事务隔离级别有哪些？各自解决了什么问题？


## 核心结论

MySQL 有四种隔离级别：**读未提交**、**读已提交**、**可重复读**、**串行化**，分别解决**脏读**、**不可重复读**、**幻读**问题，隔离级别越高并发性能越低。MySQL 默认使用**可重复读（RR）**，通过 MVCC + 间隙锁在 RR 级别下也能避免幻读。

## 隔离级别对比表

| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 性能 | 说明 |
|---------|------|-----------|------|------|------|
| 读未提交（Read Uncommitted） | ❌ 可能 | ❌ 可能 | ❌ 可能 | 最高 | 几乎不使用 |
| 读已提交（Read Committed） | ✅ 解决 | ❌ 可能 | ❌ 可能 | 较高 | Oracle 默认 |
| 可重复读（Repeatable Read） | ✅ 解决 | ✅ 解决 | ✅ 基本解决* | 中等 | **MySQL 默认** |
| 串行化（Serializable） | ✅ 解决 | ✅ 解决 | ✅ 解决 | 最低 | 几乎不使用 |

> *MySQL 的 RR 级别通过 **MVCC + 间隙锁** 机制，在大多数场景下也能避免幻读

## 三大并发问题说明

| 问题 | 定义 | 产生原因 |
|-----|------|---------|
| **脏读** | 读取到其他事务**未提交**的数据 | 事务 A 修改数据未提交，事务 B 读取到了，若 A 回滚则 B 读到的是无效数据 |
| **不可重复读** | 同一事务内多次读取**同一行**数据结果不一致 | 事务 A 两次读取之间，事务 B 执行了 **UPDATE** 并提交 |
| **幻读** | 同一事务内多次查询**结果集行数**不一致 | 事务 A 两次查询之间，事务 B 执行了 **INSERT/DELETE** 并提交 |

## 实际应用选择

| 业务场景 | 推荐隔离级别 | 理由 |
|---------|-------------|------|
| 一般业务 | RR（默认） | 平衡一致性和性能 |
| 高并发互联网业务 | RC | 避免间隙锁带来的死锁问题 |
| 金融/账务系统 | RR 或 Serializable | 保证数据强一致性 |
| 数据分析/报表 | RC | 允许不可重复读，提高并发 |
## 详细解析

### 一、并发事务带来的三大问题

在理解隔离级别之前，先理解它们要解决的问题。

#### 1.1 脏读（Dirty Read）

**读取到其他事务未提交的数据**，如果该事务回滚，读到的就是无效数据。

```
时间线：

事务A                              事务B
─────────────────────────────────────────────────
BEGIN;
UPDATE account SET balance = 200 
WHERE id = 1;  -- 原值100，改为200
                                   BEGIN;
                                   SELECT balance FROM account WHERE id = 1;
                                   -- 读到 200（脏数据！）
ROLLBACK;  -- 回滚，余额恢复为100
                                   -- 但事务B已经读到了200，这是错误的数据
                                   COMMIT;

问题：事务B读取到了事务A未提交的数据（200）
     事务A回滚后，事务B的读取结果是无效的
```

#### 1.2 不可重复读（Non-Repeatable Read）

**同一事务内多次读取同一数据，结果不一致**（被其他事务修改了）。

```
时间线：

事务A                              事务B
─────────────────────────────────────────────────
BEGIN;
SELECT balance FROM account WHERE id = 1;
-- 读到 100
                                   BEGIN;
                                   UPDATE account SET balance = 200 
                                   WHERE id = 1;
                                   COMMIT;
SELECT balance FROM account WHERE id = 1;
-- 读到 200（同一事务内两次读取结果不同！）
COMMIT;

问题：事务A在同一事务中两次读取同一数据
     第一次100，第二次200，结果不一致
```

#### 1.3 幻读（Phantom Read）

**同一事务内多次查询，结果集的行数不一致**（被其他事务插入或删除了）。

```
时间线：

事务A                              事务B
─────────────────────────────────────────────────
BEGIN;
SELECT * FROM account WHERE balance > 100;
-- 返回 2 行记录
                                   BEGIN;
                                   INSERT INTO account(id, balance) 
                                   VALUES(4, 150);
                                   COMMIT;
SELECT * FROM account WHERE balance > 100;
-- 返回 3 行记录（多了一行"幻影"数据！）
COMMIT;

问题：事务A两次相同的范围查询
     第一次2行，第二次3行，凭空多出一行"幻影"
```

**不可重复读 vs 幻读**：

```
不可重复读：针对 UPDATE，同一行数据被修改
幻读：针对 INSERT/DELETE，结果集行数变化
```

### 二、四种事务隔离级别

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           事务隔离级别对比                                    │
├─────────────────────┬───────────┬─────────────────┬───────────┬────────────┤
│      隔离级别        │   脏读    │   不可重复读     │   幻读    │   性能     │
├─────────────────────┼───────────┼─────────────────┼───────────┼────────────┤
│ READ UNCOMMITTED    │    ✗      │       ✗         │    ✗      │   最高     │
│ 读未提交            │  可能发生  │     可能发生     │  可能发生  │            │
├─────────────────────┼───────────┼─────────────────┼───────────┼────────────┤
│ READ COMMITTED      │    ✓      │       ✗         │    ✗      │   较高     │
│ 读已提交            │  已解决    │     可能发生     │  可能发生  │  (Oracle默认)│
├─────────────────────┼───────────┼─────────────────┼───────────┼────────────┤
│ REPEATABLE READ     │    ✓      │       ✓         │    ✗*     │   中等     │
│ 可重复读            │  已解决    │     已解决       │  基本解决* │ (MySQL默认)│
├─────────────────────┼───────────┼─────────────────┼───────────┼────────────┤
│ SERIALIZABLE        │    ✓      │       ✓         │    ✓      │   最低     │
│ 串行化              │  已解决    │     已解决       │  已解决    │            │
└─────────────────────┴───────────┴─────────────────┴───────────┴────────────┘

* MySQL 的 RR 级别通过 MVCC + 间隙锁，在大多数场景下也能避免幻读
```

---

#### 2.1 读未提交（READ UNCOMMITTED）

**最低的隔离级别**，事务可以读取其他事务未提交的数据。

```sql
-- 设置隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

-- 几乎不在生产环境使用
-- 唯一优点：性能最高（无锁）
-- 致命缺点：存在脏读
```

**适用场景**：几乎没有，除非对数据一致性完全不关心。

---

#### 2.2 读已提交（READ COMMITTED）

**只能读取其他事务已提交的数据**，解决了脏读问题。

```sql
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

**演示**：

```
事务A                              事务B
─────────────────────────────────────────────────
BEGIN;
UPDATE account SET balance = 200 
WHERE id = 1;
                                   BEGIN;
                                   SELECT balance FROM account WHERE id = 1;
                                   -- 读到 100（未提交的200看不到）✓
COMMIT;
                                   SELECT balance FROM account WHERE id = 1;
                                   -- 读到 200（已提交后能看到）
                                   -- 但两次读取结果不一致 ✗
                                   COMMIT;
```

**特点**：
- ✅ 解决脏读
- ❌ 存在不可重复读
- ❌ 存在幻读
- Oracle、PostgreSQL 的默认级别

---

#### 2.3 可重复读（REPEATABLE READ）⭐ MySQL 默认

**同一事务内多次读取结果一致**，解决了不可重复读问题。

```sql
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- 查看当前隔离级别
SELECT @@transaction_isolation;  -- MySQL 8.0+
SELECT @@tx_isolation;           -- MySQL 5.7
```

**演示**：

```
事务A                              事务B
─────────────────────────────────────────────────
BEGIN;
SELECT balance FROM account WHERE id = 1;
-- 读到 100
                                   BEGIN;
                                   UPDATE account SET balance = 200 
                                   WHERE id = 1;
                                   COMMIT;
SELECT balance FROM account WHERE id = 1;
-- 仍然读到 100（可重复读！）✓

COMMIT;
-- 事务结束后再查询才能看到200
```

**MySQL RR 级别的幻读处理**：

```
标准 SQL 的 RR 级别存在幻读
但 MySQL 的 InnoDB 通过以下机制避免：

1. MVCC（快照读）：SELECT 不加锁，读取事务开始时的快照
2. 间隙锁（当前读）：SELECT ... FOR UPDATE 会锁住间隙

快照读：普通 SELECT，通过 MVCC 避免幻读
当前读：SELECT ... FOR UPDATE，通过间隙锁避免幻读
```

---

#### 2.4 串行化（SERIALIZABLE）

**最高的隔离级别**，事务完全串行执行，解决所有并发问题。

```sql
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

**演示**：

```
事务A                              事务B
─────────────────────────────────────────────────
BEGIN;
SELECT * FROM account WHERE balance > 100;
-- 自动加共享锁
                                   BEGIN;
                                   INSERT INTO account(id, balance) 
                                   VALUES(4, 150);
                                   -- 阻塞！等待事务A释放锁
COMMIT;
                                   -- 事务A提交后，事务B才能执行
                                   COMMIT;
```

**特点**：
- ✅ 解决所有并发问题
- ❌ 性能最差，大量锁等待
- 几乎不在生产环境使用

---

### 三、MVCC 实现原理

MySQL 的 RR 和 RC 级别主要通过 **MVCC（多版本并发控制）** 实现。

#### 3.1 核心概念

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              MVCC 核心组件                                   │
├─────────────────────┬───────────────────────────────────────────────────────┤
│ 隐藏字段            │ DB_TRX_ID（事务ID）、DB_ROLL_PTR（回滚指针）、         │
│                     │ DB_ROW_ID（隐藏主键）                                  │
├─────────────────────┼───────────────────────────────────────────────────────┤
│ Undo Log            │ 记录数据修改前的版本，形成版本链                        │
├─────────────────────┼───────────────────────────────────────────────────────┤
│ Read View           │ 事务快照，决定能看到哪些版本的数据                      │
└─────────────────────┴───────────────────────────────────────────────────────┘
```

#### 3.2 版本链

```
每次修改数据都会生成新版本，通过 DB_ROLL_PTR 形成版本链：

┌─────────────────────────────────────────────────────────────────────────────┐
│                              版本链示例                                      │
└─────────────────────────────────────────────────────────────────────────────┘

当前数据行
┌─────────┬─────────┬───────────────┐
│ balance │ TRX_ID  │ ROLL_PTR      │
│   200   │  102    │  ──────────┐  │
└─────────┴─────────┴────────────│──┘
                                 │
                                 ▼
                    Undo Log (版本1)
              ┌─────────┬─────────┬───────────────┐
              │ balance │ TRX_ID  │ ROLL_PTR      │
              │   150   │  101    │  ──────────┐  │
              └─────────┴─────────┴────────────│──┘
                                               │
                                               ▼
                                  Undo Log (版本2)
                            ┌─────────┬─────────┬───────────────┐
                            │ balance │ TRX_ID  │ ROLL_PTR      │
                            │   100   │  100    │    NULL       │
                            └─────────┴─────────┴───────────────┘

数据被修改了3次：100 → 150 → 200
每个版本记录了修改它的事务ID
```

#### 3.3 Read View（读视图）

```
Read View 包含：
1. m_ids：生成 Read View 时活跃的事务ID列表
2. min_trx_id：m_ids 中的最小值
3. max_trx_id：生成 Read View 时系统分配的下一个事务ID
4. creator_trx_id：创建该 Read View 的事务ID
```

**可见性判断规则**：

```
对于版本链中的某个版本，其 TRX_ID 为 trx_id：

1. trx_id == creator_trx_id
   → 可见（自己修改的）

2. trx_id < min_trx_id
   → 可见（在 Read View 创建前已提交）

3. trx_id >= max_trx_id
   → 不可见（在 Read View 创建后才开始）

4. min_trx_id <= trx_id < max_trx_id
   → 如果 trx_id 在 m_ids 中：不可见（还未提交）
   → 如果 trx_id 不在 m_ids 中：可见（已提交）
```

#### 3.4 RC 与 RR 的 Read View 区别

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    Read View 生成时机对比                                    │
├─────────────────────┬───────────────────────────────────────────────────────┤
│ READ COMMITTED      │ 每次 SELECT 都生成新的 Read View                      │
│                     │ 所以能看到其他事务最新提交的数据                        │
├─────────────────────┼───────────────────────────────────────────────────────┤
│ REPEATABLE READ     │ 只在事务第一次 SELECT 时生成 Read View                 │
│                     │ 后续 SELECT 复用，所以看到的数据不变                    │
└─────────────────────┴───────────────────────────────────────────────────────┘
```

**图解对比**：

```
RC 级别：每次读取都生成新的 Read View

事务A                              事务B
─────────────────────────────────────────────────
BEGIN;
SELECT ...;  ← 生成 ReadView1
                                   UPDATE ... COMMIT;
SELECT ...;  ← 生成 ReadView2（能看到事务B的修改）
COMMIT;


RR 级别：第一次读取生成 Read View，后续复用

事务A                              事务B
─────────────────────────────────────────────────
BEGIN;
SELECT ...;  ← 生成 ReadView1
                                   UPDATE ... COMMIT;
SELECT ...;  ← 复用 ReadView1（看不到事务B的修改）
COMMIT;
```

### 四、当前读与快照读

#### 4.1 快照读（Snapshot Read）

```sql
-- 普通 SELECT 是快照读，读取 MVCC 版本链中的历史数据
SELECT * FROM account WHERE id = 1;

-- 不加锁，通过 Read View 判断可见性
```

#### 4.2 当前读（Current Read）

```sql
-- 以下操作都是当前读，读取最新的已提交数据
SELECT * FROM account WHERE id = 1 FOR UPDATE;      -- 排他锁
SELECT * FROM account WHERE id = 1 FOR SHARE;       -- 共享锁（MySQL 8.0）
SELECT * FROM account WHERE id = 1 LOCK IN SHARE MODE; -- 共享锁

-- DML 操作也是当前读
INSERT INTO account ...;
UPDATE account SET ...;
DELETE FROM account ...;

-- 当前读需要加锁，会触发间隙锁（RR级别）
```

### 五、MySQL RR 级别如何避免幻读？

#### 5.1 快照读场景 —— MVCC 避免

```
事务A                              事务B
─────────────────────────────────────────────────
BEGIN;
SELECT * FROM account WHERE balance > 100;
-- 返回 2 行，生成 Read View
                                   BEGIN;
                                   INSERT INTO account(id, balance) 
                                   VALUES(4, 150);
                                   COMMIT;
SELECT * FROM account WHERE balance > 100;
-- 仍然返回 2 行（复用 Read View，看不到新插入的）
COMMIT;

结论：快照读通过 MVCC 避免了幻读
```

#### 5.2 当前读场景 —— 间隙锁避免

```sql
-- 假设 balance 字段有索引，现有数据：balance = 50, 100, 150

事务A:
BEGIN;
SELECT * FROM account WHERE balance > 80 FOR UPDATE;
-- 加锁范围：(80, +∞) 的间隙锁 + 100、150 的行锁

事务B:
BEGIN;
INSERT INTO account(id, balance) VALUES(4, 120);
-- 阻塞！因为 120 在间隙 (100, 150) 中，被锁住了

-- 事务A 提交后，事务B 才能插入
```

**间隙锁图解**：

```
数据：50, 100, 150

SELECT ... WHERE balance > 80 FOR UPDATE 的锁范围：

(-∞, 50]  (50, 100]  (100, 150]  (150, +∞)
           ████████████████████████████████
              │            │           │
              │   行锁 100  │  行锁 150  │
              │            │           │
              └─────── 间隙锁 ─────────┘

任何想在 (80, +∞) 范围内插入的事务都会被阻塞
```

### 六、不同隔离级别的选择

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           隔离级别选择指南                                   │
├─────────────────────┬───────────────────────────────────────────────────────┤
│ 业务场景            │ 推荐隔离级别                                          │
├─────────────────────┼───────────────────────────────────────────────────────┤
│ 一般业务            │ RR（MySQL 默认），平衡一致性和性能                      │
├─────────────────────┼───────────────────────────────────────────────────────┤
│ 高并发读            │ RC，避免间隙锁带来的死锁问题                           │
│ 互联网业务          │ （很多互联网公司使用 RC 级别）                          │
├─────────────────────┼───────────────────────────────────────────────────────┤
│ 金融/账务           │ RR 或 SERIALIZABLE，保证数据强一致                     │
├─────────────────────┼───────────────────────────────────────────────────────┤
│ 数据分析/报表       │ RC，允许不可重复读，提高并发                           │
└─────────────────────┴───────────────────────────────────────────────────────┘
```

**为什么很多公司用 RC？**

```
RR 的间隙锁可能导致：
1. 更多的锁冲突和死锁
2. 并发性能下降

RC 的优势：
1. 只有行锁，没有间隙锁
2. 更高的并发性能
3. 对于大多数业务，不可重复读是可接受的

典型案例：阿里巴巴的 MySQL 规范推荐使用 RC 级别
```

### 七、实战：查看和设置隔离级别

```sql
-- 查看当前隔离级别
SELECT @@transaction_isolation;           -- 会话级别
SELECT @@global.transaction_isolation;    -- 全局级别

-- 设置会话级别（只影响当前连接）
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 设置全局级别（影响新连接，不影响已有连接）
SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 永久设置（修改配置文件）
-- my.cnf:
-- [mysqld]
-- transaction-isolation = READ-COMMITTED
```

### 八、总结

**面试回答模板**：

> "MySQL 有四种事务隔离级别：
>
> 1. **读未提交**：最低级别，存在脏读、不可重复读、幻读，几乎不用
> 2. **读已提交**：解决脏读，存在不可重复读和幻读，Oracle 默认，很多互联网公司使用
> 3. **可重复读**：解决脏读和不可重复读，MySQL 默认，通过 MVCC + 间隙锁也能避免幻读
> 4. **串行化**：解决所有问题，但性能最差，几乎不用
>
> **实现原理**：RC 和 RR 主要通过 MVCC 实现，区别在于 Read View 的生成时机——RC 每次 SELECT 都生成新的，RR 只在第一次 SELECT 时生成并复用。
>
> **MySQL RR 避免幻读**：快照读通过 MVCC 避免，当前读通过间隙锁避免。
>
> **实际选择**：一般业务用 RR（默认），高并发互联网业务可以用 RC 避免间隙锁死锁，金融业务用 RR 或串行化保证强一致。"
